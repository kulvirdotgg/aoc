package day15

import (
	"aoc/stl"
	"fmt"
)

func Solution() {
	ip := stl.ReadFile("extc.txt")

	moves := []string{}
	naksha := []string{}
	for i, line := range ip {
		if len(line) == 0 {
			naksha = ip[:i]
			moves = ip[i+1:]
			break
		}
	}
	newMap := getMap(naksha)
	newMap = goRobo(moves, newMap)
	for _, line := range newMap {
		fmt.Println(line)
	}
}

type pt struct {
	x, y int
}

func goRobo(moves []string, naksha [][]string) [][]string {
	locateBot := func() [2]int {
		robo := [2]int{}
		for r, line := range naksha {
			for c, ch := range line {
				if ch == "@" {
					robo[0] = r
					robo[1] = c
					return robo
				}
			}
		}
		return robo
	}

	for _, str := range moves {
		for _, mv := range str {
			robo := locateBot()
			// fmt.Println("robo pos is", robo)
			switch {
			case mv == '<':
				naksha = move(naksha, 0, robo[0], robo[1])
			case mv == '^':
				naksha = move(naksha, 1, robo[0], robo[1])
			case mv == '>':
				naksha = move(naksha, 2, robo[0], robo[1])
			case mv == 'v':
				naksha = move(naksha, 3, robo[0], robo[1])
			}
		}
	}
	return naksha
}

func mov(naksha [][]string, dir, row, col int) [][]string {
	dirs := [4][2]int{{0, -1}, {-1, 0}, {0, 1}, {1, 0}}

	nr, nc := row+dirs[dir][0], col+dirs[dir][1]
	box := false
	if naksha[nr][nc] == "O" {
		// fmt.Println("box detected")
		box = true
	}

	nr += dirs[dir][0]
	nc += dirs[dir][1]
	if box && naksha[nr][nc] != "#" {
		naksha[nr][nc] = "O"
	}
	naksha[nr][nc] = "@"
	fmt.Println(naksha[pr][pc], pr, pc)
}

func move(naksha [][]string, dir, row, col int) [][]string {
	dirs := [4][2]int{{0, -1}, {-1, 0}, {0, 1}, {1, 0}}

	nr, nc := row+dirs[dir][0], col+dirs[dir][1]
	for naksha[nr][nc] != "#" {
		// If new position contains a box
		box := false
		pr, pc := nr, nc
		if naksha[nr][nc] == "O" {
			fmt.Println("box detected")
			box = true
		}

		nr += dirs[dir][0]
		nc += dirs[dir][1]
		if box && naksha[nr][nc] != "#" {
			naksha[nr][nc] = "O"
		}
		naksha[pr][pc] = "@"
		fmt.Println(naksha[pr][pc], pr, pc)

	}
	for _, line := range naksha {
		fmt.Println(line)
	}
	return naksha
}

func gpsCoord(naksha [][]string) int {
	return 0
}

func getMap(naksha []string) [][]string {
	newMap := make([][]string, len(naksha))
	for r, line := range naksha {
		newMap[r] = make([]string, 0)
		for _, ch := range line {
			newMap[r] = append(newMap[r], string(ch))
		}
	}
	return newMap
}
